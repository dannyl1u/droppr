package main

import (
	"fmt"
	"net/http"
	"time"
)

// Claims a drop
func serveClaim(w http.ResponseWriter, r *http.Request) {
	setCORS(&w)

	if r.Method != http.MethodPost {
		http.Error(w,
			http.StatusText(http.StatusBadRequest),
			http.StatusBadRequest)
		return
	}

	// get drop ID from request path
	id := r.URL.Path[11:] // /api/claim/:id
	if len(id) != 6 {
		http.Error(w,
			http.StatusText(http.StatusBadRequest),
			http.StatusBadRequest)
		return
	}

	// check for an existing session in cookies; don't register if that is the case
	existingToken, existingId := getSession(r)
	if len(existingToken) > 0 && len(existingId) > 0 {
		if existingId == id {
			rows, err := db.Query(
				"SELECT drop_role FROM sessions WHERE token = $1 AND drop_id = $2",
				existingToken,
				existingId,
			)

			if err == nil && rows.Next() {
				// read the session token generated by the db
				var role string
				rows.Scan(&role) // TODO: handle error (lazy)
				rows.Close()

				// check if drop role is correct
				if role == "receiver" {
					w.Write([]byte("OK")) // requester already claimed; OK
					return
				} else {
					// the dropper is attempting to receive their own drop; bad request
					http.Error(w,
						http.StatusText(http.StatusBadRequest),
						http.StatusBadRequest)
					return
				}
			}
		}

		// if existing ID doesn't match the requesting ID, then abide the request and attempt to claim the new ID
	}

	// verify that the drop is alright (1 dropper, 0 receivers)
	rows, err := db.Query(`
		SELECT 
			COUNT(CASE WHEN drop_role = 'dropper' THEN 1 END) AS droppers,
			COUNT(CASE WHEN drop_role = 'receiver' THEN 1 END) AS receivers
		FROM sessions
		WHERE drop_id = $1`,
		id,
	)
	if err != nil || !rows.Next() {
		fmt.Printf("[Error] in request to /api/claim/%s: %v", id, err)
		http.Error(w,
			http.StatusText(http.StatusInternalServerError),
			http.StatusInternalServerError)
		return
	}

	var (
		droppers  int
		receivers int
	)
	rows.Scan(&droppers, &receivers) // TODO: handle error (lazy)
	rows.Close()

	if droppers != 1 || receivers != 0 {
		fmt.Printf("[Warning] in request to /api/claim/%s: unauthorized", id)
		http.Error(w,
			http.StatusText(http.StatusUnauthorized),
			http.StatusUnauthorized)
		return
	}

	// there is exactly 1 dropper and 0 receivers; claim this drop
	// TODO: do the above and below queries in a single transaction

	// insert a session row, generating a session token
	rows, err = db.Query("INSERT INTO sessions(drop_id, drop_role) VALUES ($1, 'receiver') RETURNING token", id)
	if err != nil || !rows.Next() {
		fmt.Printf("[Error] in request to /api/claim/%s: %v", id, err)
		http.Error(w,
			http.StatusText(http.StatusInternalServerError),
			http.StatusInternalServerError)
		return
	}

	// read the session token generated by the db
	var token string
	rows.Scan(&token) // TODO: handle error (lazy)
	rows.Close()

	// set the session_token cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "session_token",
		Value:    token,
		Path:     "/",
		Expires:  time.Now().Add(24 * time.Hour), // expires in 24 hours
		HttpOnly: true,                           // don't let JS see session_token
	})

	// set the drop_id cookie
	http.SetCookie(w, &http.Cookie{
		Name:     "drop_id",
		Value:    id,
		Path:     "/",
		Expires:  time.Now().Add(24 * time.Hour), // expires in 24 hours
		HttpOnly: true,                           // let JS see drop_id
	})

	w.Write([]byte("OK"))
}
